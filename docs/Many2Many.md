# Relacja wiele do wielu - gatunek literatury



> Unlike the quotes where there is a one-to-many relationship between a book and an array of quotes, where each book can have many quotes, each quote though is associated with only one book. In this case, a book can have many genres, but each genre can be associated with many different books. And a genre can be something like fiction, non-fiction, romance, mystery, etc. We want each of the genres to be associated with a specific color, so the user can choose that as well. So we're going to need a model for this new object, and we'll have to define our properties. So create a new file called Genre, and import SwiftData. Create a new class called Genre, and create two properties, both strings, one for the name and one for the color. We're going to be storing a hex value for a color as a string. Then make sure you apply the model macro to this class, and create an initializer. In its simplest form, a hex color is a six-digit combination of hexadecimal digits defined by its mix of red, green, and blue, RGB. So basically a hex color code is shorthand for its RGB values, with a little conversion gymnastics in between. 

W przeciwieństwie do cytatów, gdzie istnieje relacja jeden-do-wielu między książką a tablicą cytatów, gdzie każda książka może mieć wiele cytatów, każdy cytat jest powiązany tylko z jedną książką. W tym przypadku książka może mieć wiele gatunków, ale każdy gatunek może być powiązany z wieloma różnymi książkami. Gatunek może być czymś takim jak literatura piękna, literatura faktu, romans, tajemnica, itp. Chcemy, aby każdy z gatunków był powiązany z określonym kolorem, aby użytkownik mógł go również wybrać. Będziemy więc potrzebować modelu dla tego nowego obiektu i będziemy musieli zdefiniować jego właściwości. Stwórz nowy plik o nazwie Gatunek i zaimportuj SwiftData. Utwórz nową klasę o nazwie Gatunek i stwórz dwie właściwości, obie typu String - jedną dla nazwy i jedną dla koloru. Będziemy przechowywać wartość szesnastkową dla koloru jako ciąg znaków. Upewnij się, że zastosujesz makro model do tej klasy i utwórz inicjalizator. W najprostszej postaci, kolor w formacie szesnastkowym składa się z sześciu cyfr szesnastkowych, które określają jego mieszankę czerwieni, zieleni i niebieskiego, czyli RGB. Innymi słowy, kod koloru szesnastkowego jest skrótem jego wartości RGB, z niewielką konwersją pomiędzy nimi.

> Hex representations of colors use 16 bits to represent the red, green, and blue values of a color. Now there's no default way for us to provide a string for that hex value, and I want to generate a SwiftUI color view. Because there are some really smart people out there, there are some extensions that we can use. The one that I use is by Max Alexander at this link here, and I'll provide a link in the description. So let's copy the code from this first code box here. Then return to your SwiftUI project and create a new file, and call it uicolor plus extension. Change the import here to uikit, and paste that code into here. This will allow us to go between uicolors to the hex strings, but we want a Swift color view, so we'll need that second extension. So return to Max's blog, and copy the content from the second code box. Back in Xcode, create another file and call it color plus extension. Then paste the copied code, replacing the import, and that will also change the import from foundation to SwiftUI. I can return to our genre model now, and then change that import to SwiftUI, and I can create a computed property for hex color, which is of type color. Use the new color initializer for color, using the hex for self.color, and it's optional, so if for some reason it fails, we'll supply a color of red. 

Reprezentacje kolorów w formacie szesnastkowym używają 16 bitów do przedstawienia wartości czerwieni, zieleni i niebieskiego koloru. Obecnie nie ma domyślnego sposobu na dostarczenie dla nas ciągu znaków dla tej wartości szesnastkowej, a ja chcę generować widok koloru w SwiftUI. Dzięki inteligentnym ludziom dostępne są pewne rozszerzenia, których możemy użyć. Jednym z nich jest rozszerzenie stworzone przez Maxa Alexandra, dostępne pod tym linkiem (dodam link w opisie). Skopiujmy kod z tego pierwszego okna kodu. Następnie wróć do projektu SwiftUI i utwórz nowy plik nazwij go `uicolor plus extension`. Zmień import na `uikit` i wklej tam ten kod. To pozwoli nam przechodzić między kolorami `UIColor` a ciągami znaków w formacie szesnastkowym, ale chcemy stworzyć widok koloru w Swift, więc będziemy potrzebować drugiego rozszerzenia. Wróćmy więc na bloga Maxa i skopiuj zawartość drugiego okna kodu. Z powrotem w Xcode, utwórz kolejny plik i nazwij go `color plus extension`. Następnie wklej skopiowany kod, zmieniając import na `SwiftUI`. Teraz możemy wrócić do naszego modelu gatunku i zmienić import na `SwiftUI`. Możemy utworzyć obliczeniową właściwość dla koloru szesnastkowego, która jest typu `Color`. Użyj nowego inicjalizatora `Color` do przekazania wartości szesnastkowej `self.color`, a jeśli z jakiegoś powodu nie uda się go zainicjalizować, dostarczymy kolor czerwony.



> Now that we have our model, we can establish a relationship between our book model and the genre. And as I mentioned, each book can have any number of genres, or none at all, which will be the case when we create our book. And since I'm looking into the future, where we're going to want to involve CloudKit, it just makes sense here to make the properties optional. So in our book class, I'm going to create a new property, and I'll call it genres, and it's going to be an optional array of genre. If I switch to the genres class, I'll do the reverse, and I'll create a variable for books that will be an optional array of book. I'm not going to want to delete all the genres in a book's genre array, as we did with comments, when we delete one of our books. We just want to use the default nullify, but I do want to be more explicit here, and specify that be genres, and specify the inverse for the relationship, where our genre is the genre.books. I don't need to do anything else on the other side of this relationship. Now where the app starts, again I don't need to do anything special here for our app entry point to let our container know that we have another schema, because book contains a property for this new genre, so like quotes, SwiftData can handle that for us. During the design process here, and testing, I'd like to have some examples to work with. So in our preview contents folder, I'm going to create another new file, and I'm going to call it genre samples. Here I'll just create an extension to genre, and I'll create a static property called sample genres that will be an array of genre, and we can start with that empty array. So let me create four genres. 

Teraz, gdy mamy nasz model, możemy ustalić relację między naszym modelem książki a gatunkiem. Jak wspomniałem, każda książka może mieć dowolną liczbę gatunków lub w ogóle żadnego, co będzie miało miejsce, gdy tworzymy naszą książkę. Ponieważ patrzę w przyszłość, gdzie będziemy chcieli korzystać z CloudKit, ma to sens, aby tutaj właściwości były opcjonalne. W naszej klasie książki utworzę nową właściwość, nazwę ją "genres", i będzie to opcjonalna tablica obiektów typu gatunek. Jeśli przełączę się do klasy gatunku, zrobię odwrotnie, i utworzę zmienną dla książek, która będzie opcjonalną tablicą książek. Nie chcę usuwać wszystkich gatunków z tablicy gatunków książki, jak to robiliśmy z komentarzami, gdy usuwamy jedną z naszych książek. Chcemy po prostu używać domyślnej wartości nullify, ale chcę być tutaj bardziej wyraźny i określić, żeby były to gatunki i określić odwrotność relacji, gdzie nasz gatunek to gatunek.książki. Nie muszę robić nic więcej po drugiej stronie tej relacji. Teraz, gdy aplikacja się uruchamia, znowu nie muszę niczego specjalnego robić tutaj, aby nasz punkt wejścia wiedział, że mamy kolejny schemat, ponieważ książka zawiera właściwość dla tego nowego gatunku, więc jak w przypadku cytatów, SwiftData poradzi sobie z tym dla nas. Podczas procesu projektowania i testowania chciałbym mieć jakieś przykłady do pracy. Więc w naszym folderze z podglądem zawartości, utworzę kolejny nowy plik, nazwę go "genre samples". Tutaj utworzę rozszerzenie dla klasy gatunek i utworzę statyczną właściwość o nazwie "sampleGenres", która będzie tablicą obiektów typu gatunek, i możemy zacząć od pustej tablicy. Dopiszmy ze cztery gatunki.

> The first one I'm going to call fiction, and I'll specify a color of green, which is the hexadecimal 00FF00. I'll duplicate this three more times, and change it to provide a color of blue, which is 0000FF, one for romance, with the red color, which is FF0000, and then one for thriller, which is black, which is just six zeros. The next thing that I want to do if we're going to use these in our preview is to add them to our preview container. So let me go here first in our book list view, and create a property for first for sample books, then one for sample genres, each using the static properties from the extension. So then I'm going to change this first function then to call preview add example books, and then for the second one I'm going to add the examples that are our genres. We're getting a lot of files in our navigator now, so I'd like to organize them before I move on. So the first thing I'm going to do is select book list view, book list, new book view, and edit book view, and I'm going to select them all and create a new group from that selection, and I'm just going to call it books. You can organize things any way that you like, this is just how I'm doing it. Then I'm going to select my three models, the book, quote, and genre, and I'm going to create a new group from them, calling it models. I've got two extensions, so I'll select them, and I'll create a group called extensions. I've only got one quote view, but I might as well just select it and create a group on its own that I'll call quotes. Let me move it up below the books. 



Pierwszy gatunek nazwę "Literatura piękna" i ustawię kolor na zielony, czyli szesnastkowo 00FF00. Skopiuję to jeszcze trzy razy i zmienię, aby ustawić kolory na: niebieski (0000FF) dla drugiego, czerwony (FF0000) dla romansu i czarny (000000) dla thrillery. Następnie, jeśli chcemy użyć ich w naszym podglądzie, chcę dodać je do naszego kontenera podglądu. Przejdę więc do widoku listy książek, gdzie stworzę właściwość dla przykładowych książek oraz dla przykładowych gatunków, używając statycznych właściwości z rozszerzenia. Następnie zmienię tę pierwszą funkcję, aby wywoływała `previewAddExampleBooks`, a dla drugiej dodam przykłady naszych gatunków. Mamy teraz wiele plików w naszym nawigatorze, więc chciałbym je zorganizować, zanim pójdę dalej. Zatem pierwszą rzeczą, jaką zrobię, to wybiorę widok listy książek, listę książek, widok nowej książki i widok edycji książki, zaznaczę je wszystkie i utworzę nową grupę z tego zaznaczenia, nazwiję ją po prostu "Books". Możesz organizować pliki według własnego uznania, to tylko sposób, w jaki ja to robię. Następnie wybiorę moje trzy modele, książkę, cytat i gatunek, i utworzę z nich nową grupę, nazywając ją "Models". Mam dwie rozszerzenia, więc je zaznaczę i utworzę grupę nazwaną "Extensions". Mam tylko jeden widok cytatu, ale może lepiej będzie zaznaczyć go i utworzyć osobną grupę, którą nazwę "Quotes". Przenieśmy go powyżej "Books".



> Then I'm going to select the ratings view, and with it I'll just create a new group that I'll call accessory view. Now in the navigator you can select any folder, or you can get the top level at any time and use the option key and either your left or right arrows to collapse or expand all enclosing group folders. Let's create a view that will allow us to view all the available genres in the list, and at the same time allow us to select ones that might apply to a selected book. So let me create first a group that I'm going to call genre, that will contain all of the files related to this. Inside there then, let's create a new SwiftUI file that I'll call genres view, and I'll import Swift data. The view will be presented as a modal sheet, so we'll need to access the environment's dismiss keypath and create a variable for that. I'm also going to need access to the context, as I'll be presenting a list with a swipe action. So another environment variable for the keypath model context that I'll just assign to a variable called context. The query will be getting a book object from the edit book view where I'll have a button to display a sheet. This time though I want to receive the book as a bindable object. This means that we'll be able to make changes directly to any property of the book, and they'll get updated and saved by Swift data. To present a list of all genres stored in our genre table, I can use the query macro, and I'll provide a sort order that will sort by name keypath. And that'll give us a genres array. And let's fix this preview now so that we can work with it. We can do the same as we did in our book list view. I can create an instance of the preview struct, passing in book.self so that it gets all our models. 

Następnie wybiorę widok ocen i utworzę z niego nową grupę, którą nazwę "Accessory View". Teraz w nawigatorze możesz wybrać dowolny folder lub przejść na najwyższy poziom w dowolnym momencie i użyć klawisza opcji oraz strzałek w lewo lub w prawo, aby zwijać lub rozwijać wszystkie grupy folderów. Stwórzmy teraz widok, który pozwoli nam zobaczyć wszystkie dostępne gatunki w liście, jednocześnie umożliwiając wybór tych, które mogą być związane z wybraną książką. Zacznijmy od utworzenia grupy, którą nazwę "Gatunek", która będzie zawierała wszystkie pliki związane z tym zagadnieniem. Wewnątrz niej utworzymy nowy plik SwiftUI, który nazwę "GenresView", i zaimportujemy SwiftData. Ten widok będzie prezentowany jako modalny arkusz, więc będziemy musieli uzyskać dostęp do kluczowego środowiska "dismiss" i utworzyć zmienną dla tego celu. Będę również potrzebował dostępu do kontekstu, ponieważ będę prezentować listę z przesunięciem palca. Zdefiniujmy więc kolejną zmienną środowiskową dla klucza "modelContext", którą przypiszę do zmiennej o nazwie "context". Zapytanie będzie otrzymywane z obiektu książki z widoku edycji książki, gdzie będę miał przycisk do wyświetlenia arkusza. Tym razem jednak chcę otrzymać książkę jako obiekt typu "BindableObject". Oznacza to, że będziemy mogli dokonywać zmian bezpośrednio w dowolnej właściwości książki, a zostaną one zaktualizowane i zapisane przez SwiftData. Aby wyświetlić listę wszystkich gatunków przechowywanych w naszej tabeli gatunków, mogę użyć makra "query" i podać kolejność sortowania według ścieżki klucza "name". To da nam tablicę gatunków. Teraz poprawmy ten podgląd, abyśmy mogli z nim pracować. Możemy zrobić to samo, co w przypadku widoku listy książek. Mogę utworzyć instancję struktury podglądu, przekazując `book.self`, dzięki czemu otrzymamy wszystkie nasze modele.



> Remember book has relationships to the genre as well. I'll create properties for book and genre samples. And then I'm going to add those examples into our preview provider. Next though I can select one of those books, like the one at index 1, and one of the genres, say the one at index 0, and append it. Then I can return that genres view passing in that same book. And use the preview container for our model container. To design this view first, comment out the three lines in the preview that contain references for the genre. This will mean that our view doesn't have any genres yet. And I'm going to do this because I want to replace the body with the view, and if the genre SRA doesn't exist, I want to present a content unavailable view. So we'll check first to see if genres is empty. And then I'll create a content unavailable view that will allow us to provide some kind of content, a description, and a button action. So for the content we'll create an image using the system image bookmark.fill. And I'll set the font to a large title. For the description I'll create a new text view, and I'll just use the string, you need to create some genres first. And for the action I'm going to create a button with the label create genre, but I'll leave the action for the button empty for now. But I will set the button style to a bordered prominent style. So that was the case if there are no genres, so else, assuming we now have genres, it's not empty, we can display a list using a for each loop to loop through each genre that will provide us with a genre that we can display the genre's name with. Let's enclose that entire if else clause inside a group. And then I'll enclose the group inside a navigation stack. That's going to allow me then to apply a navigation title of book title to the group. Well now we're seeing that content unavailable view prompting you to create a genre. However if we uncomment our lines for genre, the list appears. Well now we can fix up our view within the list. 

Pamiętaj, że książka ma również relacje z gatunkiem. Stworzę właściwości dla przykładowych książek i gatunków. Następnie dodam te przykłady do naszego dostawcy podglądu. Następnie mogę wybrać jedną z tych książek, na przykład tę o indeksie 1, i jeden z gatunków, na przykład ten o indeksie 0, i dodać go. Następnie mogę zwrócić ten widok gatunków, przekazując tę samą książkę. Użyję kontenera podglądu dla naszego kontenera modelu. Aby zaprojektować ten widok, na początku zakomentuj trzy linie w podglądzie, które odnoszą się do gatunku. Oznacza to, że nasz widok nie ma jeszcze żadnych gatunków. Chcę to zrobić, ponieważ chcę zastąpić treść widoku widokiem. Jeśli gatunek nie istnieje, chcę wyświetlić widok z informacją o niedostępnej zawartości. Najpierw sprawdzimy, czy gatunki są puste. Następnie utworzę widok z informacją o niedostępnej zawartości, który pozwoli nam podać jakąś treść, opis i akcję przycisku. Dla treści utworzymy obraz, używając systemowego obrazka "bookmark.fill". Ustawmy czcionkę na dużą tytułową. Dla opisu utworzę nowy widok tekstowy i użyję napisu "Musisz najpierw stworzyć jakieś gatunki". A dla akcji utworzę przycisk z etykietą "Utwórz gatunek", ale na razie zostawię akcję dla tego przycisku pustą. Ustawię jednak styl przycisku na wyraźny wypukły. To dotyczy sytuacji, gdy nie ma jeszcze żadnych gatunków. W przeciwnym razie, zakładając, że teraz mamy gatunki, które nie są puste, możemy wyświetlić listę, używając pętli "for each" do iteracji przez każdy gatunek. Będzie to dostarczać nam gatunek, którego możemy użyć do wyświetlenia nazwy gatunku. Obejmijmy całe to wyrażenie if-else w grupie. Następnie umieśćmy tę grupę w nawigacyjnym stosie. Dzięki temu będę mógł zastosować tytuł nawigacyjny "Tytuł książki" do grupy. Teraz widzimy widok z informacją o niedostępnej zawartości, zachęcający do utworzenia gatunku. Jednak jeśli odkomentujemy nasze linie dla gatunku, lista pojawi się. Teraz możemy dostosować nasz widok wewnątrz listy.

> So we'll embed the text view in an hstack. And then for the first element in the hstack we're going to create a button that we can toggle to add or remove that genre for that book. So first let me unwrap book genres and check if it's empty or not. If it's empty we can create a button and leave the action empty for now. The image will be a system name, circle. And I don't know why my preview keeps crashing on me but when I edit the code it comes back. Let's add a foreground style of genre's hex color. In the else clause then we'll create a button, same empty action, but the label is going to be conditional on whether or not the book genre contains the genre. If it does then we'll use circle.fill, else we'll just use a circle. And again I'll apply a foreground style of genre.hexcolor. We see that our first genre of fiction must be an array because we added that in our preview. So outside of our struct let's code our function to add or remove genres. Using a genre that was passed in. So we'll call it addRemoveGenres with that one parameter. Well we can unwrap our book genres array with an if let. Then if book genres is empty we can append our genre to the book genres array. Else if it's not empty we need to know if the existing book genres array contains that genre. And at the same time determine the index by finding the first index from the book genres where its id is equal to the genre id. If we can find it we can remove it at that index. If we can't we'll need to append it to the genres array. So with that function in place now we can call it in our action buttons passing in that genre. Now we can tap on a genre to add it to the list or remove it from the book genres array. The preview container is updating our book in memory. Now that we can present genres we'll need to be able to create new ones. So let's start by creating a new SwiftUI view inside the genres group and I'll call it new genre view. And I'll import Swift data. I'm going to need two state properties that we can use to create our new genre. One for the name and one for the color. The name will be a string that we can initialize as an empty string. But color is going to be a color view that we can use in a color picker to change so set the default to red. We'll be creating a new genre object so we'll need access to the context from the environment. 

Zagnieżdżymy nasz widok tekstowy w hstack. Dla pierwszego elementu w hstack stworzymy przycisk, który będziemy mogli przełączać, aby dodać lub usunąć ten gatunek dla tej książki. Najpierw sprawdzimy, czy bookGenres nie jest puste. Jeśli jest puste, możemy utworzyć przycisk i na razie zostawić pustą akcję. Obraz będzie pochodził z systemowego zestawu, a mianowicie "circle". Nie wiem, dlaczego mój podgląd ciągle mi się zawiesza, ale kiedy edytuję kod, wraca do normy. Dodajmy jeszcze styl wypełnienia (foreground) koloru gatunku. W przeciwnym razie, w klauzuli else, utworzymy przycisk z tą samą pustą akcją, ale etykieta będzie warunkowa, w zależności od tego, czy bookGenre zawiera gatunek czy nie. Jeśli tak, użyjemy "circle.fill", w przeciwnym razie użyjemy po prostu "circle". Ponownie zastosujmy styl wypełnienia koloru hex gatunku. Widzimy, że nasz pierwszy gatunek, "Literatura piękna", musi być tablicą, ponieważ dodaliśmy go w naszym podglądzie. Więc poza naszą strukturą zdefiniujmy funkcję do dodawania lub usuwania gatunków, które zostały przekazane. Nazwijmy ją "addRemoveGenres" z tym jednym parametrem. Odpakujmy naszą tablicę gatunków książki za pomocą "if let". Następnie, jeśli bookGenres jest puste, możemy dodać nasz gatunek do tablicy bookGenres. W przeciwnym razie, jeśli nie jest puste, musimy sprawdzić, czy istniejąca tablica bookGenres zawiera ten gatunek. Jednocześnie musimy znaleźć indeks, szukając pierwszego indeksu w tablicy bookGenres, gdzie jego id jest równe id gatunku. Jeśli go znajdziemy, możemy go usunąć z tego indeksu. Jeśli nie możemy go znaleźć, musimy go dodać do tablicy bookGenres. Teraz, gdy ta funkcja jest gotowa, możemy ją wywołać w naszych przyciskach akcji, przekazując ten gatunek. Teraz możemy dotknąć gatunku, aby dodać go do listy lub usunąć z tablicy gatunków książki. Kontener podglądu aktualizuje naszą książkę w pamięci. Teraz, gdy możemy prezentować gatunki, będziemy musieli mieć możliwość tworzenia nowych. Zacznijmy od utworzenia nowego widoku SwiftUI wewnątrz grupy "Gatunek" i nazwijmy go "NewGenreView". Zaimportujmy SwiftData. Będę potrzebować dwóch właściwości stanu, których możemy użyć do utworzenia naszego nowego gatunku. Jeden dla nazwy i jeden dla koloru. Nazwa będzie ciągiem znaków, który możemy zainicjalizować jako pusty ciąg. Ale kolor będzie widokiem koloru, który możemy użyć w selektorze kolorów do zmiany, więc ustaw domyślnie na czerwony. Będziemy tworzyć nowy obiekt gatunku, więc będziemy potrzebować dostępu do kontekstu z otoczenia.

> So we'll access that model context and call it context. And this will be presented as a modal sheet so again let's provide the ability to dismiss using the dismiss key path from the environment to create a dismiss property. I'm going to replace the body with a navigation stack containing a form. As the first item in the form I'll create a text view with the title key, name and bind it to the name state property. And then I'm going to follow that with a color picker where the title key is set the genre color and the selection will be bound to that color state property. I'm also going to ignore opacity so the supports opacity argument here is going to be set to false. And then I'm going to create a button with a label create. For the action we'll create a new genre where the name is our name. For the color we'll need to convert the color to a hex string using our extension. Now this has to be force unwrap because it's optional but since it'll be coming from the color picker itself it's safe to force unwrap it here. And now that both are strings we can use the context to insert the model. And then we can dismiss it. Well let me set the button style to bordered prominent. And I'm going to apply a frame and set the max width to infinity with an alignment of trailing and that's going to push it to the right hand side of our form. And to make sure that we don't get any empty colors we'll disable it if the name is empty. Then into the form I'll add some padding. I'll create a navigation title using the string new genre. But I'll set the navigation bar title display mode to inline. Now if you tried to create one here the app would crash because we have not set up our preview container. However there's not much point in doing that here. Let's return to our genre view and add a button to present this. So as the last row in the list after the for each loop create a labeled container view using content and label. For the content I'm going to create a button but I'll leave the action empty for now. For the button label I'll create an image using the system name plus dot circle dot fill. And I'll set the image scale to large. And I'll also set a button style of bordered prominent. 

Dostaniemy się do tego kontekstu modelu i nazwiemy go "context". Widok ten będzie prezentowany jako modalny arkusz, więc znowu umożliwmy jego zamknięcie, korzystając z klucza środowiska "dismiss" w celu utworzenia właściwości "dismiss". Zamienię ciało widoku na nawigacyjny stos zawierający formularz. Jako pierwszy element formularza utworzę widok tekstowy z kluczem tytułowym "name" i zbindowaną właściwością stanu "name". Następnie dodam do tego selektor kolorów, gdzie klucz tytułowy będzie ustawiony na "genreColor", a wybór będzie zbindowany z właściwością stanu "color". Ignoruję także opcję przezroczystości, więc argument "supportsOpacity" będzie ustawiony na "false". Następnie utworzę przycisk z etykietą "Utwórz". Dla akcji utworzymy nowy gatunek, gdzie nazwa będzie równa naszej nazwie. Dla koloru będziemy musieli przekształcić kolor na ciąg szesnastkowy za pomocą naszego rozszerzenia. Musi to być "force unwrap", ponieważ jest to opcjonalne, ale ponieważ będzie pochodzić bezpośrednio z selektora kolorów, jest bezpieczne do "force unwrap" w tym miejscu. Teraz, gdy obie wartości są ciągami, możemy użyć kontekstu do wstawienia modelu. Następnie zamkniemy ten widok. Ustawmy też styl przycisku na "borderedProminent". Zastosujmy ramkę, ustawiając maksymalną szerokość na "infinity" z wyjustowaniem do prawej strony, co przesunie go na prawą stronę naszego formularza. Aby upewnić się, że nie uzyskamy pustych kolorów, zdezaktywujemy przycisk, jeśli nazwa jest pusta. Do formularza dodam też odrobinę marginesu. Utworzymy nawigacyjny tytuł, używając ciągu "New Genre", ale ustawmy tryb wyświetlania tytułu paska nawigacyjnego na "inline". Teraz, jeśli spróbujesz utworzyć jeden tutaj, aplikacja by się zawiesiła, ponieważ nie skonfigurowaliśmy jeszcze naszego kontenera podglądu. Niemniej jednak nie ma sensu tego robić tutaj. Wróćmy do naszego widoku gatunków i dodajmy przycisk, który ten widok będzie prezentować. Tak więc, jako ostatni wiersz w liście po pętli "for each", utwórzmy widok z etykietą, używając zawartości i etykiety. Dla zawartości utworzymy przycisk, ale na razie pozostawmy akcję pustą. Dla etykiety przycisku utworzymy obrazek, używając nazwy systemowej "plus.circle.fill". Ustawimy skalę obrazka na "large". Zastosujemy również styl przycisku na "borderedProminent".

> For the label of the labeled content itself I'm going to create a new text view using the string create new genre. And I'll apply a captioned font and set the foreground style to secondary. Let me also set the list style here to plain. The button that we created will be used to present a modal sheet so I'm going to create a new state property called new genre and initialize it as false. And then for the action of that button we created we'll just toggle this state property. Sometimes I find that just commenting a line and uncommenting a line of code fixes these false preview crashes. It's also important now that we go back to that content unavailable view where we had that action button, we can do that same new genre toggle here as well. And then once it's toggled we'll need to present a sheet so we'll create a sheet modifier where is presented is bound to that toggle and we'll use that to present the new genre view. And I'm going to create a toolbar so I can get a button that's going to allow me to dismiss the screen. And then inside there I'm going to create a toolbar item where the placement is top bar leading to have it on the leading edge and I'll create a button that I'll call back that simply calls the dismiss function. Now this itself, this view, needs to be presented from the edit book view just like where we created the button to present our quotes view. So I'm going to go back to the edit book view and create a state property for show genres and set it to false. So where we have that navigation link to present our quotes I'm going to embed that in an h stack to present both of these buttons side by side and then as the first item in the h stack I'll create a button where the title key is genres but now in Xcode 15 we can also add a system image to our button label. So I'll specify bookmark.fill. And for the action I'll simply toggle show genres. 

Dla etykiety samego widoku "labeled content" utworzę nowy widok tekstowy, używając napisu "Create New Genre". Zastosuję czcionkę podpisu (captioned font) i ustawię styl wypełnienia (foreground style) na "secondary". Ustawmy również styl listy na "plain". Przycisk, który utworzyliśmy, będzie używany do prezentowania arkusza modalnego, więc utworzę nową właściwość stanu o nazwie "newGenre" i zainicjalizuję ją jako "false". Następnie dla akcji tego przycisku po prostu przełączymy tę właściwość stanu. Czasami zauważam, że zakomentowanie i odkomentowanie linii kodu naprawia te fałszywe błędy podglądu. Teraz ważne jest, aby wrócić do widoku z informacją o niedostępnej zawartości, gdzie mieliśmy ten przycisk akcji. Możemy również użyć tego samego przełączania "newGenre" tutaj. Po przełączeniu go będziemy musieli wyświetlić arkusz, więc utworzymy modyfikator "sheet", gdzie "isPresented" będzie zbindowane z tym przełącznikiem i użyjemy go do prezentowania widoku "NewGenreView". Utworzę również pasek narzędzi, aby dostać przycisk, który pozwoli mi zamknąć ekran. Następnie wewnątrz tego paska narzędzi utworzę element paska narzędzi, gdzie położenie (placement) będzie ustawione na "top bar leading", aby umieścić go na krawędzi wiodącej, i utworzę przycisk, który nazwę "Back" i po prostu wywoła funkcję "dismiss". Teraz ten widok sam w sobie musi być prezentowany z widoku edycji książki, dokładnie tak samo, jak utworzyliśmy przycisk do prezentacji widoku "QuotesView". Więc wrócę do widoku edycji książki i utworzę właściwość stanu dla "showGenres" i ustawię ją na "false". Gdzie mamy ten link nawigacyjny do prezentacji naszych cytatów, zagnieżdżę go w hstack, aby pokazać oba te przyciski obok siebie, a jako pierwszy element w hstack utworzę przycisk, gdzie klucz tytułowy to "Genres", ale teraz w Xcode 15 możemy również dodać obraz systemowy do etykiety naszego przycisku. Więc podam "bookmark.fill". A dla akcji po prostu przełączę "showGenres".

> Now that we have that show genres action toggle I can create a sheet that's going to present our genres view. So that sheet is going to be bound to is presented to show genres and then I can create the genres view passing in that book. Well if you return now to book list view we can test out in the preview. Tap on any row and you'll get the detail view. And from here we can tap on the genres button. And I can set one or two genres for my book. If I tap on back I don't see the genres added yet because we haven't quoted that. That's next. But if I return to the genres view I'll see that they must have been inserted because they're still selected. So let me try adding a new genre. I'm going to call it action. And I'm going to pick a color. And add it. And we can see that it's been added alphabetically to the list. If I select it and go back it'll get inserted. If I return I would see that new genre has persisted and it's been selected. So we have two more things to do. I want to create a nice way to display the selected genres on this detail view as well as the list view. And we'll still need to be able to delete a genre that we no longer want altogether and make sure that it gets removed also from each of the books. Since I want the same look to be on both the list view and on the detail I'm going to create a SwiftUI view to present our stack of genres. So I'll create a new SwiftUI file that I'll call genreStackView. Now this view will receive an array of genres when it's presented. So we'll call that genres. And then I'll replace the body with an hStack. And then we'll just use a forEach loop on our genres array. That'll give us a genre. I'm also going to sort the array using the keypath comparator which will be our genre name. So then we can just create a text view using that genre name. I'll set the font to a caption. Foreground style to white. I'll apply some padding of 5. And then I'll set the background to a rounded rectangle with a corner radius of 5 and a fill that uses that genre's hex color. Now I'm not going to use a preview here as this is a pretty simple view. So we can add this then to our two views. So in bookListView where we do our query in the navigation link label and in the vStack after the reading, I'll use an iflet to determine if we have an array of genre. And then just display that genreStackView passing in that array. 

Teraz, gdy mamy przełącznik akcji "showGenres", mogę utworzyć arkusz, który będzie prezentować nasz widok gatunków. Ten arkusz będzie zbindowany z "isPresented" do właściwości "showGenres", a następnie mogę utworzyć widok "GenresView", przekazując do niego tę książkę. Teraz, jeśli wrócimy teraz do widoku listy książek, możemy to przetestować w podglądzie. Dotknij dowolnego wiersza, a dostaniesz widok szczegółowy. A stąd możemy nacisnąć przycisk gatunków. I mogę wybrać jeden lub dwa gatunki dla mojej książki. Jeśli naciśnę przycisk "Wstecz", nie zobaczę jeszcze dodanych gatunków, ponieważ jeszcze tego nie obsłużyliśmy. To jest następne. Ale jeśli wrócę do widoku gatunków, zobaczę, że musiały zostać one dodane, ponieważ są wciąż zaznaczone. Pozwól mi teraz spróbować dodać nowy gatunek. Nazwę go "akcja". I wybiorę kolor. I dodam go. I widzimy, że został on dodany alfabetycznie do listy. Jeśli go wybiorę i wrócę, zostanie wstawiony. Jeśli wrócę, zobaczę, że nowy gatunek pozostał i został zaznaczony. Mamy jeszcze dwie rzeczy do zrobienia. Chcę stworzyć ładny sposób na wyświetlanie wybranych gatunków na tym widoku szczegółów, jak również na widoku listy. I nadal będziemy musieli być w stanie usunąć gatunek, którego już nie chcemy, oraz upewnić się, że zostanie on również usunięty z każdej z książek. Ponieważ chcę, aby wygląd był taki sam zarówno na widoku listy, jak i na szczegółowym, stworzę widok SwiftUI do prezentacji naszego stosu gatunków. Więc utworzę nowy plik SwiftUI, który nazwę "GenreStackView". Teraz ten widok otrzyma tablicę gatunków podczas prezentacji. Nazwiemy ją "genres". Następnie zastąpię ciało widoku hstackiem. I użyjemy pętli forEach na naszej tablicy gatunków. To da nam gatunek. Posortuję również tablicę, używając porównywacza klucza ścieżki, którym będzie nazwa naszego gatunku. Wówczas po prostu utworzymy widok tekstowy, używając tej nazwy gatunku. Ustawię czcionkę na podpis (caption). Styl wypełnienia na biały. Dodam trochę marginesu 5. A następnie ustawiam tło na zaokrąglony prostokąt o promieniu rogu 5 i wypełnieniu, które używa koloru szesnastkowego tego gatunku. Teraz nie będę używać podglądu tutaj, ponieważ to dość prosty widok. Więc możemy dodać to do naszych dwóch widoków. Więc w widoku listy książek, gdzie wykonujemy nasze zapytanie w etykiecie nawigacyjnego linku oraz w vStack po polu "reading", użyję iflet, aby sprawdzić, czy mamy tablicę gatunków. I po prostu wyświetlę ten widok "GenreStackView", przekazując tę tablicę.

> So I can copy this then and use that same code in our editBookView after the text editor for the synopsis but before the two buttons. So let me return to bookListView and test it out. Well this is almost perfect except what if we had lots of genres? We may run out of space in this horizontal stack. So to prove this let me launch this in my simulator. And you'll see I've added quite a few more genres for this set of books. And for one in particular I have assigned a lot of genres. Now it looks ok here but let me go and add one more genre to this book. Back in editView now it doesn't look so good as it's trying to cram all of those genres in this row. And if I get back to the listView it's even worse. If it were in a scrollView there wouldn't be a problem. Well it turns out that it's a pretty easy fix. We can simply use a viewThatFits to view only use a scrollView if necessary. And I use this as an example in my video on viewThatFits. So in the books.lists file I'm going to embed the genreStacksView in a viewThatFits. And then I'm going to as the second view add a scrollView that is horizontal and set the shows indicators to false and then present that genreStackView passing in the genre. So I'm going to use this exact same code in the editBookView. Let me run this out in the simulator now. And I can see it looks perfect. Not only in the list but also in the detailView. It only scrolls if necessary. Now the last thing I want to cover is deleting a genre from the genres array. Deleting a genre won't force any deletion of a related book because the default is just to nullify. So that's going to be OK. We're going to need to do this in the simulator so if you're following along make sure that you have added a number of books, a number of genres, and have genres related to a number of different books. What I want to do first though is to open that SQL database to see what the structure currently looks like. If I view the data for this book I see no representation of the array of genre. But notice that this first column though, z underscore pk, that stands for the primary key. For example, the book qb7 has a primary key of 1. Similarly if I view the data for genre, there is no mention of books here, but there is another primary key field here too. 

Więc mogę skopiować to i użyć tego samego kodu w naszym widoku `editBookView` po polu tekstowym dla streszczenia, ale przed dwoma przyciskami. Więc wróćmy do widoku `bookListView` i przetestujmy to. To jest prawie idealne, ale co jeśli mielibyśmy wiele gatunków? Możemy wyczerpać miejsce w tym poziomym stosie. Aby to udowodnić, pozwól mi uruchomić to w symulatorze. Zobaczysz, że dodałem dość dużo więcej gatunków dla tej grupy książek. A dla jednego z nich przypisałem wiele gatunków. Teraz wygląda to dobrze tutaj, ale pozwól mi dodać jeszcze jeden gatunek do tej książki. Teraz, w widoku `editView`, nie wygląda to tak dobrze, ponieważ próbuje wcisnąć wszystkie te gatunki w ten wiersz. A jeśli wrócę do widoku `listView`, jest jeszcze gorzej. Gdyby to było wewnątrz `scrollView`, nie byłoby problemu. Okazuje się, że jest to dość łatwe do naprawienia. Po prostu możemy użyć `viewThatFits`, aby widok używał `scrollView`, tylko jeśli to konieczne. Użyłem tego jako przykład w moim filmie o `viewThatFits`. Więc w pliku `books.lists` zamknę `genreStacksView` w `viewThatFits`. Następnie jako drugi widok dodam `scrollView`, który jest poziomy i ustawię `showsIndicators` na `false`, a następnie przekażę ten `genreStackView` przekazując gatunek. Użyję dokładnie tego samego kodu w widoku `editBookView`. Teraz uruchommy to w symulatorze. Widzę, że wygląda idealnie. Nie tylko na liście, ale także w widoku szczegółów. Przewija się tylko w razie potrzeby. Teraz ostatnią rzeczą, którą chcę omówić, jest usuwanie gatunku z tablicy gatunków. Usunięcie gatunku nie spowoduje żadnego usunięcia związanej z nim książki, ponieważ domyślnie zostanie tylko znullowana. Więc to będzie w porządku. Będziemy musieli to zrobić w symulatorze, więc jeśli podążasz za mną, upewnij się, że dodałeś wiele książek, wiele gatunków i masz gatunki powiązane z różnymi książkami. Najpierw chcę jednak otworzyć tę bazę danych SQL, aby zobaczyć, jak aktualnie wygląda struktura. Jeśli przeglądam dane tej książki, nie widzę żadnej reprezentacji tablicy gatunków. Ale zauważ, że ta pierwsza kolumna, oznaczona jako `z_pk`, oznacza klucz główny. Na przykład książka `qb7` ma klucz główny 1. Podobnie, przeglądając dane dla gatunku, nie ma tu wzmianki o książkach, ale jest inna kolumna klucza głównego.

> When we create a many-to-many relationship in SwiftData, behind the scenes a new join table is created. In this case it's called z underscore one genres. If I open it up, we'll see that it has two columns, one for books and one for genres, and the list here is the primary keys for each record. So you can see here that the book with the primary key 1, that's rqb7, has genres 1 and 6. And if I switch to genres, I see that 1 is fiction and 6 is historical. So if I return to the app once more, I'll be able to see that in fact that is the case. So what I want to do now then is cover the deletion of that entire genre to see what happens. So in genres view I created the list of genres using a forEach loop. So we can use an onDelete modifier here for swipe action. I should just be able then to loop through the index set, create an index, and then use the delete method to delete from the genres array at that index. So let's run this now in our simulator. And I can see that the detective genre is associated with two books. So let me delete it. I'm going to select one of the books with the detective genre, and then I'll bring up the genre screen where I now have that swipe action right to left to delete it. When I return to the book detail view though, it's still there. This is a problem. However, if I return to the list view though, that genre is no longer being displayed for any book. The problem is that when we present our genres view and delete the genre, there is no binding back to that specific array for our book. The solution, however, is pretty easy. We just have to remove the book first from the array that will update the view that's presenting this, and then I can delete the genre, which will then automatically update the list view. So here we can unwrap book.genres using an if let and see at the same time if that book genres contains genres at that genres index. If that's the case then, we can let the book genres index be the first index where the genre ID for this book's genre is equal to the one at the index of the entire array. And then we can remove that at the book genre index. 

Kiedy tworzymy relację wiele do wielu w SwiftData, za kulisami tworzona jest nowa tabela łącząca. W tym przypadku nosi ona nazwę `z_one_genres`. Jeśli ją otworzę, zobaczę, że ma dwie kolumny, jedną dla książek i jedną dla gatunków, a lista tu to klucze główne każdego rekordu. Można zobaczyć, że książka o kluczu głównym 1, czyli `rqb7`, ma gatunki 1 i 6. A jeśli przejdę do gatunków, zobaczę, że 1 to fikcja, a 6 to historia. Wróćmy do aplikacji raz jeszcze, aby sprawdzić, czy to się zgadza. Teraz chcę przetestować usunięcie całego gatunku, aby zobaczyć, co się stanie. Więc w widoku gatunków utworzyłem listę gatunków przy użyciu pętli `forEach`. Możemy więc tutaj użyć modyfikatora `onDelete` dla akcji przesunięcia w lewo. Powinienem być w stanie przejść przez ten zestaw indeksów, utworzyć indeks, a następnie użyć metody `delete`, aby usunąć z tablicy gatunków pod tym indeksem. Uruchommy to teraz w naszym symulatorze. Widzę, że gatunek "Detektyw" jest powiązany z dwiema książkami. Pozwól mi go usunąć. Wybiorę jedną z książek z gatunkiem "Detektyw", a następnie pojawię się na ekranie z gatunkami, gdzie teraz mam przesunięcie akcji od prawej do lewej, aby go usunąć. Po powrocie do widoku szczegółów książki, nadal jest tam ten gatunek. To jest problem. Jednakże, po powrocie do widoku listy, tego gatunku już tam nie ma. Problem polega na tym, że kiedy prezentujemy widok gatunków i usuwamy gatunek, nie ma powiązania z tą konkretną tablicą dla naszej książki. Rozwiązanie jest jednak dość proste. Musimy po prostu najpierw usunąć książkę z tej tablicy, co zaktualizuje widok, który ją prezentuje, a następnie mogę usunąć gatunek, co automatycznie zaktualizuje widok listy. Więc tutaj możemy odczytać `book.genres`, używając `if let`, jednocześnie sprawdzając, czy `book.genres` zawiera gatunki pod indeksem gatunków. Jeśli tak jest, to możemy ustawić `bookGenresIndex` jako pierwszy indeks, gdzie ID gatunku dla gatunku tej książki jest równe indeksowi całej tablicy. Następnie możemy usunąć ten indeks z `bookGenresIndex`.

> So let's test one more time. I see fiction is associated with many books, so let me select any book that has fiction. I can see it here in the detail view, so let me go to the genre screen and swipe to delete that fiction genre. When I return to the detail screen, I see it's no longer displayed here. And then returning to list view, we see it's gone from every book. Well, that pretty much completes the basics of this app for SwiftData, but there's still a couple more things that I'd like to do with this app. So if you're interested, you can stick with me for the next couple of videos. One of them is SwiftData related and the other one isn't. In the next video of this series, I want to talk about localization and how we can make our app available in other languages. That's not SwiftData related at all, but I want to cover it before I get into CloudKit, which is. If I did this after CloudKit, people starting with that repository as a starter project may have some issues related to CloudKit, so I'm going to leave it to the end. So I hope you stick with me until we finish this series. Thanks. Bye. Bye. you Thank you.

Pozwólmy sobie przetestować jeszcze raz. Widzę, że gatunek 'fiction' jest powiązany z wieloma książkami, więc pozwól mi wybrać dowolną książkę z tego gatunku. Widzę ją tutaj w widoku szczegółów, więc przejdźmy do ekranu gatunków i przesuńmy, aby usunąć ten gatunek 'fiction'. Po powrocie do ekranu szczegółów widzę, że już go tu nie ma. A wracając do widoku listy, widzę, że zniknął z każdej książki. Cóż, to praktycznie kompletna podstawa tej aplikacji opartej na SwiftData, ale nadal mam kilka rzeczy, które chciałbym zrobić z tą aplikacją. Jeśli jesteś zainteresowany, możesz pozostać ze mną przez kolejne filmy. Jeden z nich dotyczy SwiftData, a drugi nie. W następnym filmie tej serii chcę porozmawiać o lokalizacji i tym, jak możemy udostępnić naszą aplikację w innych językach. To nie jest związane z SwiftData w ogóle, ale chcę to omówić przed przejściem do CloudKit, które jest związane. Gdybym to zrobił po CloudKit, osoby zaczynające z tym repozytorium jako projektem startowym mogłyby napotkać pewne problemy związane z CloudKit, więc zostawiam to na koniec. Mam nadzieję, że pozostaniesz ze mną do końca tej serii. Dzięki. Do widzenia. Do zobaczenia! Dziękuję.